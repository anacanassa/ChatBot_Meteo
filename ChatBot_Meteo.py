# -*- coding: utf-8 -*-
"""ChatBot_Meteo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zqM0fAotGAu_jA5drMCxDGtY2uKJP79H

Instala√ß√£o de biblioteca e configurac√£o da chave da API
"""

!pip install -q -U google-genai

from google import genai
from google.colab import userdata

api_key = userdata.get("GEMINI_API_KEY")
if not api_key:
    raise ValueError("SECRET GEMINI_API_KEY n√£o encontrado!")

client = genai.Client(api_key=api_key)

"""Fun√ß√£o de Limpeza do JSON recebido pela resposta do Gemini"""

import json
import re

def clean_gemini_json(text: str) -> str:
    """Remove markdown, espa√ßos e extrai apenas o JSON v√°lido."""
    if not text:
        return text

    # Remove blocos ```json e ``` simples
    text = text.replace("```json", "").replace("```", "")

    # Remove espa√ßos extras no in√≠cio e fim
    text = text.strip()

    # Se houver mais de um JSON no texto, pegar apenas o primeiro {...}
    match = re.search(r"\{.*\}", text, re.DOTALL)
    if match:
        text = match.group(0)

    return text

"""Fun√ß√£o de tratamento do Formato de Data recebido pelo Gemini"""

from datetime import date, timedelta, datetime
import unicodedata
import re

def _normalize_token(s: str) -> str:
    """Normaliza: remove acentos, pontua√ß√£o, lower e trim."""
    if not isinstance(s, str):
        return ""
    # remove acentos
    s = unicodedata.normalize("NFKD", s).encode("ASCII", "ignore").decode("utf-8")
    # lower e strip
    s = s.lower().strip()
    # remove pontua√ß√£o (ex.: "atual.", "hoje!")
    s = re.sub(r"[^\w\s]", "", s)
    # normaliza espa√ßos m√∫ltiplos
    s = re.sub(r"\s+", " ", s)
    return s

def parse_date(date_str: str):
    """
    Converte uma string para datetime.date:
    - aceita tokens relativos: 'hoje', 'atual', 'agora', 'amanha', 'ontem' (varia√ß√µes com/sem acento)
    - aceita ISO YYYY-MM-DD
    - aceita DD/MM/YYYY e DD-MM-YYYY
    - retorna datetime.date ou None se n√£o conseguir interpretar
    """
    if date_str is None:
        return None

    token = _normalize_token(date_str)

    today = date.today()

    if token in {"hoje", "atual", "agora", "today"}:
        return today
    if token in {"amanha", "amanh√£", "amanha", "tomorrow"}:
        return today + timedelta(days=1)
    if token in {"ontem", "yesterday"}:
        return today - timedelta(days=1)

    # tenta ISO YYYY-MM-DD
    try:
        return datetime.fromisoformat(token).date()
    except Exception:
        pass

    # tenta DD/MM/YYYY e DD-MM-YYYY
    for fmt in ("%d/%m/%Y", "%d-%m-%Y"):
        try:
            return datetime.strptime(date_str.strip(), fmt).date()
        except Exception:
            pass

    # N√£o conseguiu interpretar
    return "N√£o entendi"

#print(parse_date("atual"))

"""Fun√ß√£o de pergunta ao Gemnini"""

def ask_gemini_extract_params(user_question: str):
    try:
        prompt = f"""
        Extraia em JSON os seguintes par√¢metros da pergunta do usu√°rio:
        - city: nome da cidade
        - date: data em formato YYYY-MM-DD ou em data relativa (hoje, amanha, ontem, agora, atual)
        - info: tipo de informa√ß√£o clim√°tica (temperature ou weathercode)

        Pergunta: "{user_question}"

        Responda SOMENTE com um JSON.
        """

        response = client.models.generate_content(
            model="gemini-2.5-flash",
            contents=prompt
        )

        text = response.text

        cleaned = clean_gemini_json(text)

        params = json.loads(cleaned)
        return params

    except Exception as e:
        print(f"Erro ao chamar Gemini: {e}")
        return None

##print(ask_gemini_extract_params("Qual o clima atual de S√£o Paulo?"))

"""Fun√ß√£o de consulta das Coordenadas da Cidade pesquisada"""

import requests

def get_city_coords(city_name: str):
    """
    Busca latitude e longitude de uma cidade usando Open-Meteo Geocoding API.
    """
    try:
        url = f"https://geocoding-api.open-meteo.com/v1/search?name={city_name}&count=1&language=pt&format=json"
        response = requests.get(url, timeout=10)

        if response.status_code != 200:
            print("Erro na API de geolocaliza√ß√£o:", response.status_code)
            return None

        data = response.json()

        # Nenhum resultado encontrado
        if "results" not in data or len(data["results"]) == 0:
            return None

        # Primeiro resultado da API
        result = data["results"][0]

        lat = result.get("latitude")
        lon = result.get("longitude")

        if lat is None or lon is None:
            return None

        return lat, lon

    except Exception as e:
        print(f"Erro ao consultar coordenadas: {e}")
        return None

"""Fun√ß√£o de consulta do Clima no Open Meteo"""

weather_map = {
0: "C√©u limpo",
1: "Predominantemente claro",
2: "Parcialmente nublado",
3: "Nublado",
61: "Chuva fraca",
63: "Chuva moderada",
65: "Chuva forte",
95: "Tempestade"
}

import requests
from datetime import datetime

def get_weather(lat, lon, target_date):
    """
    Consulta a API Open-Meteo e retorna:
    - temperatura m√°xima (float)
    - condi√ß√£o clim√°tica traduzida (string)
    """

    try:
        url = (
            "https://api.open-meteo.com/v1/forecast?"
            f"latitude={lat}&longitude={lon}"
            "&daily=temperature_2m_max,weathercode"
            "&timezone=America/Sao_Paulo"
        )

        response = requests.get(url)
        response.raise_for_status()
        data = response.json()

        dates = data["daily"]["time"]
        temps = data["daily"]["temperature_2m_max"]
        codes = data["daily"]["weathercode"]

        target_str = target_date.isoformat()

        if target_str not in dates:
            return None, None

        idx = dates.index(target_str)
        temp = temps[idx]
        code = codes[idx]

        condition = weather_map.get(code, "Condi√ß√£o n√£o dispon√≠vel")

        return temp, condition

    except Exception as e:
        print("Erro no get_weather:", e)
        return None, None

"""Fun√ß√£o do Chatbot com as Chamadas Gerais das Fun√µes"""

def chatbot_full(user_question: str):
    params = ask_gemini_extract_params(user_question)


    if not params:
        return "N√£o consegui entender sua pergunta. Tente reformular."

    city = (params.get("city") or "").strip().title()
    date_str = params.get("date") or ""
    info = params.get("info") or ""

    if not city:
        return "Pergunte novamente informando sua Cidade"

    coords = get_city_coords(city)
    if not coords:
        return f"N√£o consegui encontrar coordenadas para '{city}'."

    lat, lon = coords

    target_date = parse_date(date_str)
    if not target_date:
        return f"Data inv√°lida: {date_str}"

    # Consulta Open-Meteo
    temp, cond = get_weather(lat, lon, target_date)
    if temp is None:
        return f"Sem dados clim√°ticos para {city} em {target_date}."

    if info == "temperature":
        return f"A temperatura m√°xima em {city} em {target_date} ser√° de {temp}¬∞C."
    else:
        return f"A condi√ß√£o clim√°tica em {city} em {target_date} ser√°: {cond}."


#print(chatbot_full("Qual o clima atual de S√£o Paulo?"))

print("üå¶Ô∏è Chatbot Meteorol√≥gico iniciado! Digite 'sair' para encerrar.\n")

while True:
    question = input("Voc√™: ")
    if question.lower() == "sair":
        break

    answer = chatbot_full(question)
    print("Bot:", answer, "\n")
